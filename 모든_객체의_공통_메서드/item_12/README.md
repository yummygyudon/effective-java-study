# [Item 12] `toString`을 항상 재정의하라
<details open>
    <summary><b>Index</b></summary>
<div markdown="1">

- [toString의 효용](#tostring-의-효용)
- [toString 포맷 명시 및 문서화](#포맷-명시-및-문서화)
  - [장점](#장점)
  - [단점](#단점)
- [객체의 정보를 제공하는 API를 제공하자](#데이터-api-제공)

</div>
</details>

<br/>

---
> ⁜ **`toString` 재정의 - 대표적인 규약**<br/>
> 1. **간결**하면서도 **사람이 읽기 쉬운** 형태로 <u>객체에 대한 유익한 정보</u>를 반환해야 한다.
> 2. 모든 <u>**하위** 클래스 / **구체** 클래스</u>에서 `toString`을 재정의해야 한다.

## `toString`의 효용
기본적인 `toString` 메서드는 `[ClassName]@[Hash Code - hex]`의 포맷으로 반환한다.<br/>
이는 1번 조건에서 간결하다는 조건에는 부합할 순 있어도<br/>
객체에 대한 유익한 정보를 제공한다 보긴 어렵다.

`toString` 메서드는 클라이언트가 직접 호출하지 않더라도<br/>
다양한 순간에 빈번하게 사용된다.<br/>
`println`, `printf`, 문자열 연결 연산자 (`+`), `assert`구문, 그리고 디버거가 객체에 대해 출력할 때<br/>
자동으로 불리게 되는 것이 바로 `toString` 메서드이다.

특히 이 디버거를 통해 로그를 남길 때, `[ClassName]@[Hash Code - hex]`포맷으로 출력되면<br/>
프로그래머는 확인하고픈 데이터를 확인하기가 어려워지고 결국 쓸모 없는 메시지로 전락하게 된다.

<br/>

그렇기 때문에 `toString`을 제대로 정의하면<br/>
**처리 현황 파악**을 위한 좋은 메시지를 남길 수 있을뿐더러<br/>
**컬렉션**(`Map`, `Set`, `List`,...)과 같이 인스턴스들을 포함하는 객체에서 유용하게 쓰일 수 있다.

즉, `toString`메서드를 통해 " **그 객체가 가진 주요 정보 모두를 반환**하게끔 " 재정의하여<br/>
<u>**객체가 스스로를 완벽히 설명**하여 한 눈에 필요한 정보를 파악하고 전달</u>할 수 있어야 한다.<br/>
(_물론, 거대한 객체라면 그 중에서도 핵심 정보만 요약하는 형태로 Customizing을 할 수 있다._)

<br/>

## 포맷 명시 및 문서화
> ⁜ `toString` 구현 → " 반환값의 **포맷 문서화 여부** " 결정

`toString` 구현은 객체의 정보를 눈으로 확인하는 것에서 끝내는 것이 아닌
다른 클라이언트에게 데이터를 넘기는 경우까지 고려해야 한다.

우선 반환하는 핵심 정보가 단순 기본 타입 데이터가 아닌
연속적인 문자열, 특정 패턴을 가진 데이터, 행렬 등과 같은 값 클래스 데이터라면
문서화하는 것이 바람직하다.

### 장점
포맷을 명시하여 문서화하게 되면<br/>
해당 객체에 대해 표준적이며 명확한 가독성을 제공한다.

이에 따라 `toString` 반환 값 자체를 입출력에 사용하는 것을 넘어<br/>
csv 파일처럼 새로운 데이터 객체로 저장하여 활용할 수도 있다.<br/>
(_반환 값 자체를 입출력에 사용하는 것 : ex. toString을 특정 템플릿에 데이터를 융합하여 클라이언트에 바론 랜더링할 수 있는 형태의 문자열로 제공할 수 있음_)

✵ 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 정적 팩토리나 생성자를 함께 제공해주면 좋다.<br/>( _실제 Java 플랫폼의 많은 '값 클래스'가 따르는 방식 : ex. 기본 타입 클래스 BigInteger, BigDecimal_ ) 

<br/>

### 단점
포맷을 명시함에 있어 장점이 있다면 단점도 당연히 존재한다.

우선 한 번 명시된 포맷의 사용 빈도가 높아지게 되면<br/>
평생 해당 포맷을 수정하기 힘들어진다.

이미 해당 포맷을 사용한 사용자들의 코드들이<br/>
해당 포맷에 맞춰 파싱하여 활용하는 코드이기 때문에 포맷을 바꾸는 순간 문제가 발생하는 것은 시간 문제가 되는 것이다.

즉, 포맷이 명시된다면 유지보수성과 유연성이 현저히 떨어지게 되는 것이다.<br/>
( 명시 ❌ : 향후 릴리즈에서 정보 추가 및 삭제, 수정을 통한 개선이 가능한 유연성을 얻을 수 있음. )
> ❗️<u>포맷 명시 여부와 상관없이</u><br/> `JavaDoc` 등을 활용하여 **해당 `toString` 포맷에 대한 의도를 명확하게 밝히는 것**이 바람직하다.

<br/>

## 데이터 API 제공
만약 데이터만을 제공하는 API가 없는 상태에서<br/>
해당 객체의 정보를 활용해야 하지만<br/>
해당 정보의 <u>접근자를 제공하지 않는다면</u><br/>
`toString`을 통해 얻은 **문자열을 파싱**해서 사용하는 수밖에 없다.<br/>
(`toString` 문자열이 준-표준 API라고 봐도 무방할 것이다.)

물론 우연찮게 <u>getter 메서드가 있어</u> 수고스럽겠지만 **일일이 조회**해서 만들 수도 있다.<br/>
하지만 그러기 위해서는 _<u>사전에 해당 객체의 핵심정보가 무엇인지부터 해당 객체의 해당 핵심정보를 가져오는 getter메서드 이름까지 파악해야한다.</u>_<br/>
(~~이 얼마나 비효율적인 작업인가..~~)

어쨋든 위와 같이 상당히 번거로운 작업을 통해 데이터를 얻게되면<br/>
당연스럽게도 **성능이 저하**되고<br/>
<u>포맷이 바뀌는 순간</u> 모든 수고가 **무용지물**이 되어버린다.

<br/>

물론 <u>정적 유틸리티 클래스</u>나 대부분의 <u>열거 타입</u>의 경우,<br/>
이미 완벽한 `toString`이 제공되니 재정의할 필요가 없지만<br/>
" <u>**하위 클래스**</u> " / " <u>**구체 클래스**</u> "라면 상황이 달라진다.

하위 클래스들이 <u>**공유해야 할 문자열 표현**이 추상 클래스라면</u> 재정의가 필요하다.<br/>
(_ex. **컬렉션 구현체** : 추상 컬렉션 클래스들의 `toString` 메서드를 상속하여 사용_)

