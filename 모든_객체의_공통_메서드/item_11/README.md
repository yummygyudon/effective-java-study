# [Item 11] `equals`를 재정의하려거든 `hashCode`도 재정의하라
<details open>
    <summary><b>Index</b></summary>
<div markdown="1">

- [hashCode 작성 요령](#좋은-hashcode-작성-요령)

</div>
</details>

<br/>

---
`equals`를 재정의한 클래스라면 무조건 `hashCode`도 재정의해야 한다.

만약 재정의하지 않을 경우 `HashMap` / `HashSet` 같은 컬렉션의 원소로서 사용될 때,<br/>
잘못된 hash값 처리로 문제가 발생한다.

> 1. `equals` 비교에 <u>사용되는 정보가 변경되지 않았다면</u><br/>애플리케이션이 **실행되는 동안** 그 객체의 `hashCode` 메서드를 몇 번 호출하더라도 <br/>**항상 일관된 같은 값**을 반환해야 한다.<br/><br/>
> 2. `equals(Object)`가 두 객체를 <u>같다고 판단</u>했다면 <br/>`hashCode` 또한 **값은 값을 반환**해야 한다.<br/><br/>
> 3. `equals(Object)`가 두 객체를 <u>다르게 판단</u>했더라도<br/> 두 객체의 hashCode는 **서로 다른 값이 반환할 필요는 없다.**<br/>(단, <u>다른 값을 반환하는 것이 Hash Table의 성능이 좋아진다.</u>)<br/><br/>
> 
> _- ⌜ Object 명세 ⌟ -_

가장 중요한 부분은 두 객체가 논리적으로 같은 객체일 땐 꼭 같은 해시코드를 반환해야 한다.<br/>
`equals`메서드는 **물리적으로 다른 두 인스턴스**일지라도 <u>논리적으로 같을 경우</u>, true를 반환하게 할 수 있다.

하지만 Object의 기본 hashCode 메서드는 **다르다고 판단**하여
조건과 맞지 않게 **서로 다른 hash 값을 반환**하게 된다.

이상적인 해시 함수는 서로 다른 인스턴스에는 서로 다른 해시코드를 반환하는 것과
더불어 주어진 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.

### 좋은 hashCode 작성 요령
1. int 변수 result 선언 & <u>**동치 여부 결정** 핵심 필드 값을 계산( `2.i` 방식 )한 해시코드</u>로 **초기화**
2. **나머지 핵심 필드들**에 대해 **해시 코드 연산** 작업 수행
   1. 해당 필드의 해시코드 계산
      1. 기본 타입 필드 : `Type.hashCode()` 수행
      2. **참조 타입** 필드 & 본 클래스에서 **해당 참조 타입의 `equals` 재귀 호출**<br/> : `hashCode`도 **재귀 호출**<br/>(_복잡해질 경우, "**필드 표준형**"을 만들어 표준형의 hashCode 호출 / `null`일 경우, 0 사용_)
      3. **배열** 필드 : <br/>- 핵심 원소 각각을 별도 필드처럼 재귀적으로 규칙을 적용<br/>- 각 핵심 원소 해시코드 연산<br/>- `2.ii` 방식으로 갱신<br/>( 만약 핵심 원소가 <u>없다</u> : 단순 상수를 사용(`0`) / <u>모든 원소</u>가 핵심 원소 : `Arrays.hashCode`)
   2. `2.i` 단계에서 계산한 해시코드로 result 갱신 ( `result - 31 * result + (hashCode)` )
3. 해시코드 반환

> ⁜ **result 값을 31로 곱하는 이유** : <u>비슷한 필드가 여러 개일 때 효과</u>가 두드러짐. (_ex. String의 경우, 모두 **아나그램**의 해시코드가 같아진다._)
> <br/>
> <br/>
> ⁜ **31**인 이유 : **홀수 + 소수** & **시프트 연산**과 같은 결과 → _짝수 + 오버플로우 발생 시, 정보 유실 발생_
> <br/>
> <br/>
> _✵ 아나그램 : 구성하는 철자가 같고 그 순서만 다른 문자열 (ex. apple, paple)_

위 방식처럼 연산되는 hashCode를 통해 논리적 동치를 비교할 수 있다.

가지고 있는 필드들을 통해 해당 hashCode를 연산하기 때문에 <br/>
<u>equals **비교에 사용되지 않은 필드**</u>는 <u>반드시 **제외**</u>해야 하며<br/>
<u>파생 필드</u> 혹은 다른 필드로부터 계산이 가능한 <u>종속 필드/연관 필드</u>들은 모두 무시해도 된다.

> ✵ hash 충돌이 적은 방법으로 hashCode 연산 : Guava - Hashing 참고 (`com.google.common.hash.Hashing`) _ [더 알아보기](https://guava.dev/releases/21.0/api/docs/com/google/common/hash/Hashing.html)
 
Object 클래스는 임의의 개수만큼 객체를 받아 해시코드를 계산해주는<br/>
정적 메서드 `hash`를 제공하기 때문에<br/>
아쉽게도 속도는 느리지만 <br/>
해당 메서드를 활용하면 단 한 줄로 hashCode 함수를 작성할 수 있다.

<br/>

- hashCode <u>계산 비용이 큰 **불변** 클래스</u> : hashCode **캐싱** 


- 주로 <u>hash 연산의 **키**로 사용</u>되는 클래스 : <u>인스턴스가 만들어질 때</u> **사전**에 **hashCode 계산**


- hash 연산의 키로 사용되지 않는 클래스 : hashCode가 처음 호출될 때 계산하는 **지연 초기화(lazy initialization)** 활용<br/>(_필드를 지연 초기화하기 위해서는 해당 클래스를 **스레드 안전**하게 만들도록 신경써야 함._)

<br/>
<br/>

성능을 높이기 위해 hashCode 연산에 핵심 필드를 생략하게 되면<br/>
속도는 빨라지겠지만<br/>
품질이 떨어져 Hash Table의 성능이 심각하게 저할될 수 있으니 " <u>**핵심 필드는 생략하지 말고 연산에 활용**</u>해야 한다. "

또한
hashCode 값의 **연산 및 생성 규칙을 API 사용자에게 자세히 공표하지 않아야지만** <br/>
<u>**클라이언트**의 hash값 **의존도를 완화**</u>시키고 <u>**규칙 유지 보수성**이 향상</u>료된다.