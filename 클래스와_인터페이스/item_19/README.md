# [Item19] 상속을 고려해 설계하고 문서화하라 (그러지 않았다면 상속 금지)
<details open>
    <summary><b>Index</b></summary>
<div markdown="1">

- [문서화](#문서화)
  - [좋은 문서화](#좋은-api-문서란--about-class-related-상속-)


</div>
</details>

<br/>

---
#### 🌟 핵심 🌟
```text
* 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서화해야 한다.
  - 내부 사용에 대해 문서화를 안하면 하위 클래스 오동작을 야기할 수도 있다.
  - 일부 메서드를 protected로 제공해야할 수도 있다.

* 클래스를 확장할 명확한 이유가 떠오르지 않으면 상속을 금지하는 것이 바람직하다.
  - 상속을 금지하려면 " 클래스를 final로 선언 "하자.
  - 상속을 금지하려면 " 생성자 모두를 private/package-private "으로 만들자.
    ( 정적 팩토리화 )
```

<br/>

---
## 문서화
" _<u>메서드를 **재정의** 하면 어떤 일이 일어나는지</u>_ " 를 정확히 정리하여 문서로 남겨야 한다.<br/>

#### ⁜ "상속용 클래스"는 <u>재정의할 수 있는 메서드</u>들을 " <u>내부적</u>으로 어떻게 이용하는지 "(`자기사용`) 문서로 남겨야 한다.

<br/>

> ☑️ < 클래스의 API로 공개된 메서드 > 에서 클래스 <u>자신의 또 다른 메서드</u> 호출이 가능하다.<br/>
> 단, 해당 메서드가 만약 재정의 가능 메서드이다.<br/>
> 
> ⁜ _**재정의 메서드** : `public`과 `protected` 메서드 중 `final`이 아닌 모든 메서드_

- "<u>**재정의 가능 메서드**임</u>"을 호출하는 메서드(`< 클래스의 API로 공개된 메서드 >`)의 API 설명에 적시
- 어떤 순서로 호출하는지
- 각각의 호출 결과가 이어지는 처리에 어떤 영향을 끼치는지

<br/>

> 상속이 캡슐화를 해치기 때문에<br/>
> <u>본래 기술하지 않았어야 하지만</u> "**안전한 상속**"을 위해
> 
> "**내부 구현 방식**"을 설명해야 한다.

<br/>

### 좋은 API 문서란 ( _about Class related 상속_ )
- 클래스 <u>내부 동작 과정 중간에 끼어들 수 있는</u> `훅(hook)`을 잘 선별하여<br/>
  `protected` 메서드 형태로 공개할 때도 있다.<br/><br/>
- `protected` 로 노출해야할 메서드를 결정할 때, **상속용 클래스를 시험**해보고 공개한다.
  - <u>상속용 클래스를 시험하는 방법</u>은 <u>직접 **하위 클래스**를 **만들어보는** 것</u>이 **유일**하다<br/><br/>
- 널리 쓰일 클래스를 상속용으로 설계한다면<br/>
  <u>문서화한 **내부 사용 패턴**</u>과 `protected` 메서드와 필드를 <u>구현하면서 선택한 결정</u>에 **책임**질 수 있어야 한다.
  - 상속용으로 설계한 클래스는 <u>**배포 전**에 반드시 **하위 클래스**를 만들어 **검증**</u>해야 한다.<br/><br/>
- 상속용 클래스의 "**생성자**"는 <br/>직접적으로든 간접적으로든 <u>재정의 가능 메서드를 호출해서는 안된다</u>.
  - `private`/`final`/`static` 메서드는 재정의가 불가능하기 때문에<br/>
    생성자에서 안심하고 호출해도 된다.<br/><br/>
- **직렬화**(**Serialization**)의 `readObject()`와 **Object**의 `clone()` 모두<br/>
  직접적으로든 간접적으로든 <u>**재정의 가능한 메서드**를 호출해선 안된다</u>.

<br/>

사실 위와 같은 여러 주의점을 감수하며 클래스를 설계할바엔<br/>
가장 좋은 방법은<br/>
<u>상속용으로 설계하지 않은 클래스</u>는 "**상속을 금지**하는 것"이 가장 바람직하다.