# [Item 7] 다 쓴 객체 참조를 해제하라.
<details open>
    <summary><b>Index</b></summary>
<div markdown="1">

- [스택](#1-스택)
- [캐시](#2-캐시)
- [리스너/콜백](#3-리스너콜백)

</div>
</details>

<br/>

---
`C`언어나 `C++`언어와 같이 메모리를 직접 관리하는 언어가 아닌<br/>
**가비지 컬렉터**(이하, GC)를 사용하는 언어의 경우,<br/>
가비지 컬렉터가 다 쓴 객체에 대해서 알아서 회수해가는 탓에<br/>
자칫 메모리 관리에 소홀해 질 수 있다.

하지만 가비지 컬렉터가 비참조 객체에 대한 관리를 하더라도<br/>
메모리 누수는 충분히 발생할 수 있음을 명심해야한다.

## 1. 스택
아래의 예시를 보게 되면<br/>
`pop`메서드에서는 `--size`에 해당하는 값을 return 해줄 뿐<br/>
해당 자리에 있는 객체에 대해서 아무런 조치를 하지 않는다.

클라이언트 측에서는 가장 뒤에 있는 값을 return 받으니<br/>
마치 값을 뺀 것처럼보이지만<br/>
`elements`안에서 size값으로 **참조하는 객체만 바뀐 것**이지<br/>
<u>실제로 참조가 사라진 것이 아니다</u>.

당연히 이에 따라 가비지 컬렉터는 **더이상 사용하지 않더라도** <br/>
<u>비활성 영역에 위치한 여전히 다 쓴 참조들</u>을 **똑같이 유효하다 판단**하기 때문에<br/>
<u>회수하지 않게</u> 된다.
```java
public class Stack {
    private Object[] elements;
    private int size;
    ...
    
    public Object pop(){
        if(size == 0){
            throw new EmptyStackException();
        }
        return elements[--size];
    }
    ...
}
```
해당 객체들만 단독으로 회수하지 않는 것이 아니라<br/>
다 쓴 참조 객체와 <u>참조 관계로 얽혀있는 모든 객체들</u>을 **회수되지 않는 것**이 큰 문제이다.

이러한 상황이 반복되면<br/>
**가비지 컬렉션 활동**과 **메모리 사용량**이 늘어나 결국 성능 저하를 피할 수 없다.<br/>
( _심할 경우, <u>디스크 페이징</u>이나 <u>`OutOfMemoryError`</u>를 발생시켜 프로그램이 예기치 않게 종료될 수 있다._ )

>스택은 자기 메모리를 직접 관리하기 때문에<br/>
> `elements` 배열과 같이 저장소 풀(pool)을 만들어 원소들을 관리하게 된다.<br/>
> 그에 따라 해당 배열 내에서는 활성 영역과 비활성 영역으로 분리되겠지만<br/>
> GC입장에서는 활성 영역과 비활성 영역 모두 여전히 참조되는 배열이라 볼 수 밖에 없다.
<br/>

### 해결법
해당 참조를 다 썼을 때 `null`처리(참조 해제)를 하면 된다.<br/>
(<u>GC에게 해당 객체는 더 이상 사용하지 않는다고</u> 알림)
- 이미 처리된 객체를 실수로 사용하려고 할 때, `NullPoiterException`을 던지게 됨으로써<br/>
<u>휴먼 에러를 사전에 발견</u>할 수 있다는 장점.
- **"예외적인 경우에만 사용"**

단, null처리를 사용하게 되면<br/>
자칫 **코드가 지저분**해질 수도 있으며 일일이 신경써야 하기 때문에 **인적 자원 낭비**도 불가피해지기 때문에<br/>
예외적인 경우에만 사용해야 하는 것이다.

사실 가장 바람직한 다 쓴 참조 해제 방법은<br/>
"**<u>해당 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것</u>**"이다.<br/>
( **변수의 범위를 최소**가 되게끔 정의 _ _ex. 전역 변수 → 인스턴스 변수 → 지역 변수_)
```java
public Object pop(){
    if(size == 0){
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null;
    return result;
}
```

> ⁜ **_자기 메모리를 직접 관리하는 클래스라면<br/>
> 프로그래머가 <u>직접 항상 메모리 누수에 주의</u>해야 한다._**

✵ **디스크 페이징** : RAM에서의 공간이 부족해 하드 디스크의 영역까지 사용하여 페이징하는 현상<br/>
✵ **활성 영역** : 프로그램에서 여전히 사용할 자원들의 영역

<br/>

---
## 2. 캐시
- 객체 참조를 캐시에 넣었지만 이를 까먹고 해당 참조를 다 쓴 뒤에도 한참을 놔두게 되는 상황

<br/>

### 해결법
1. 캐시 <u>**외부**에서 키(key)를 참조하는 동안만</u> **엔트리가 살아있는 캐시**가 필요한 상황 <br/>→ `WeakHashMap`을 사용하여 캐시 생성
    - **다 쓴 엔트리**는 <u>즉시 자동 제거</u>
    - " _위와 같은 상황에서만 사용_ "


2. 시간이 지날수록 **엔트리의 가치를 떨어뜨리는** 방식 **[권장]**
   - 쓰지 않는 엔트리를 <u>이따금 청소</u>해줘야 함.
   - "**백그라운드 스레드**" 활용 (_ex. `ScheduledThreadPoolExecutor`_) or<br/>
   새 엔트리를 "추가할 때 **부수 작업**" 수행 (_ex. `LinkedHashMap` : `removeEldesEntry` 메서드_)
     - <u>더 복잡</u>한 캐시 → `java.lang.ref` 패키지 직접 활용

<br/>

---
## 3. 리스너/콜백
- 클라이언트가 콜백을 등록만 하고 **명확히 해지하지 않은 경우**
  - 콜백이 계속적으로 <u>누적</u>

<br/>

### 해결법
콜백에 대해서 "<u>**약한 참조**(weak reference)</u>"로 저장하면<br/>
GC가 **즉시 수거**<br/>
(_ex. `WeakHashMap`에 key로 저장_)