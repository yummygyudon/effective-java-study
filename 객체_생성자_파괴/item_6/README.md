# [Item 6] 불필요한 객체 생성을 피해✵.
<details open>
    <summary><b>Index</b></summary>
<div markdown="1">

- [불변 클래스 재사용](#불변-클래스-재사용)
- [생성 비용 비싼 객체 재사용](#생성-비용이-비싼-객체-재사용)
- [불필요한 객체 생성](#불필요한-객체-생성)
  - [1. 어댑터](#1-어댑터)
  - [2. 오토박싱](#2-오토박싱--auto-boxing-)

</div>
</details>

<br/>

---
보통 똑같은 기능의 객체가 있다면<br/>
매번 생성하기 보단 하나를 재사용하는 것이 효율적이다.

- `String s = new String("...")` : 실행될 때마다 새로운 String 인스턴스 생성
  - _같은 값을 가진 인스턴스가 매우 많이 생성될 위험이 있음_


- `String s = "..."` : `"..."`의 값을 가진 **String 인스턴스**가 JVM 메모리 안에 **저장**되고<br/>
같은 JVM 안에서 <u>똑같은 문자열 리터럴을 사용하는 모든 코드</u>는<br/>
해당 인스턴스를 **재사용**

즉, 재사용은 **빠르고 세련**되었으며<br/>
특히 **불변 객체**는 <u>언제든 **재사용**이 가능</u>하다.

<br/>

## `불변 클래스` 재사용
생성자 대신<br/>
**정적 팩토리**(불변 객체)의 정적 팩토리 메서드를 사용하여<br/>
불필요한 객체 생성을 피할 수 있다.<br/>
( 생성자 : 호출할 때마다 새로운 객체 생성 / 팩토리 메서드 : 새로운 객체 생성 ❌ )

물론<br/>
<u>사용 중 **변경되지 않는다는 것**이 확실</u>하다면<br/>
**가변 객체**도 재사용 될 수 있다.

<br/>

## `생성 비용이 비싼 객체` 재사용
> _"**캐싱**"하여 재사용하는 것을 권장_

클래스 내에서 불변으로 사용되는 자원(인스턴스)에 대해서<br/>
클래스 초기화(정적 초기화) 과정에서 직접 생성하여 캐싱해두고<br/>
나중에 해당 자원을 사용하는 메서드가 호출될 때마다 재사용하는 방식을 통해 개선할 수 있다.

- <u>따로 구분</u>하여 초기화해주고 <u>이름</u>까지 있기 때문에 **의미 전달/가독성**이 개선된다.

```java
/**
 * String.matches() 메서드는 내부에서 정규식에 대해 Pattern 인스턴스를 생성함.
 * 하지만 한 번 쓰고 버려지기 때문에 바로 G.C의 대상이 됨.
 */
public class NameValidator {
    private static final Pattern REGEX = Pattern.compile();
    static boolean isFormatCorrect(String name){
        return name.matches("[정규식]");
    }
}

/**
 * Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신(finite state machine)를 만들기 때문에
 * 생성에 비용이 높아짐
 * 
 * → Pattern 인스턴스를 따로 분리하여 개선
 // 메서드 호출 때마다 재사용
 */
public class NameValidator {
    private static final Pattern REGEX = Pattern.compile("[정규식]");
    static boolean isFormatCorrect(String name){
        return REGEX.matcher(s).matches();
    }
}
```

## 불필요한 객체 생성
당연히 자원을 사용하는 메서드가 만약 한 번도 호출되지 않는다면<br/>
해당 자원은 쓸데없이 초기화된 것이다.

_* **메서드가 처음 호출될 때** 필드(자원)를 초기화하는 " `지연 초기화(Lazy Initialization)`"로<br/>
불필요한 초기화를 없앨 수 있지만 권장하진 않음.<br/>
(성능은 크게 개선되지 않지만 코드만 복잡해짐)_

### 1. 어댑터
**실제 작업**은 <u>뒷단 객체에게 위임</u>하고<br/>
**어댑터 객체**는 제 2의 인터페이스로 **중개자** 역할을 해주는 객체다.

즉, 어댑터는 <u>뒷단 객체만 관리해주면 되기 때문에</u><br/>
해당 객체 외에는 관리할 상태가 없으므로 1대1 관계로 만들어지면 충분하다.

하지만 해당 어댑터 객체를 호출할 때마다 새로운 인스턴스가 만들어지는지 어떨지는 모르겠지만<br/>
중요한 것은 만약 여러 개의 인스턴스가 있다고 하더라도<br/>
**특정 인스턴스(뒷단 객체)를 대변**하기 때문에 <u>어댑터 객체가 여러 개 있을 필요가 없게 된다</u>.<br/>
( _결론은 **쓸데 없다는 것 → 무차별적으로 사용하는 것을 지양**하자._ )


### 2. 오토박싱 (Auto Boxing)
> : <u>기본 타입과 박싱된 기본 타입을 섞어 쓸 때</u> 자동으로 **상호 변환**해 주는 기능

기본 타입과 그에 대응하는 박싱된 기본 타입과 의미 상의 차이는 없어 보이지만<br/>
성능에서의 박싱 기능은 분명히 영향을 끼친다.

예를 들어보자.
- 메서드 반환 타입 : `long`
- 메서드가 연산하여 반환할 결과 변수 타입   `Long`
- 연산에 쓰이는 타입 : `long`

위와 같은 가정하에 굉장히 많은 반복을 수행하게 되면<br/>
반복 때마다 결과 변수 타입에 맞추기 위해 long 값을 가진 Long 인스턴스를 생성하게 되어<br/>
엄청난 비용이 발생하게 된다.

즉, 박싱된 기본 타입보다는 **기본 타입을 사용**하고,<br/>
**의도치 않은 오토박싱**이 <u>숨어들지 않도록 주의</u>해야 한다.

---
<br/>

프로그램의 **명확성, 간결성, 기능**을 위해서 객체를 <u>**추가 생성**하는 것은 좋으나</u><br/>
반대로<br/>
아주 무거운 비싼 비용의 객체가 아니고서야<br/>
단순히 <u>객체 생성을 피하고자</u><br/>
<u>**자체 객체 풀**까지 만들지 않는 것</u>이 좋다.<br/>
( 코드 **가독성 저하** + **메모리 낭비** + **성능 저하** )

> " _**기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라.**_ "<br/>
> ⇵ <br/>
> " _**새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라.**_ " <br/>_- [Item 50](https://github.com/yummygyudon/effective-java-study/tree/main/%eb%a9%94%ec%84%9c%eb%93%9c/item_50) -_
> 
> ✵ _<u>방어적 복사가 필요한 상황</u>에서 **객체를 재사용**했을 때의 피해가 <br/>
> 필요없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다. <br/>(버그 & 보안 이슈)_
---
✵ _유한 상태 머신(Finite State Machine) : 한 번에 오로지 하나의 상태만을 가지는 추상 기계(객체)_