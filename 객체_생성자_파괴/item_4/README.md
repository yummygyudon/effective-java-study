# [Item 4] 인스턴스화를 막으려거든 "private 생성자"를 사용하라

<details open>
    <summary><b>Index</b></summary>
<div markdown="1">

- [인스턴스화 방지](#인스턴스화-방지)

</div>
</details>

<br/>

---
> _* <u>**단순 정적 메서드 및 정적 필드만을 가지는 클래스**</u>는 객체 지향적 설계와는 거리가 멀다._

- ⟪ **단순 정적 메서드 및 정적 필드만을 가지는 클래스**를 만드는 경우 ⟫
  - <u>기본 타입 값</u> 모아 놓는 경우 : `java.lang.Math`
    <br/><br/>
  - <u>자료 구조 관련 메서드들</u>을 모아 놓는 경우 : `java.util.Arrays`
    <br/><br/>
  - **특정 인터페이스를 구현**하는 객체의 생성을 위한 <u>정적 메서드/팩토리</u>를 모아 놓을 경우
    - _Java 8 부터는 정적 메서드를 인터페이스에 넣을 수 있다._
      <br/><br/>
  - <u>`final` 클래스와 관련한 메서드들</u>을 모아 놓는 경우
    - " _final 클래스 상속을 통해 메서드를 넣는 것_ "은 **불가능**하기 때문

    

<br/>

<u>생성자를 명시하지 않으면</u><br/>
**컴파일러**가 **자동**으로 기본 생성자를 만들어 준다.

→ _매개변수를 받지 않는 `public` 생성자 생성_<br/>
→ _사용자는 의도를 파악할 수 없음_

그렇다고 _**추상 클래스**로 만든다 하더라도_<br/>
**하위 클래스**를 만들어 인스턴스화할 수 있기 때문에 소용 없다.<br/>
(_오히려 추상 클래스로 만들면 상속해서 쓰라는 의미로 받아들여지기 쉬움._)

<br/>

### 인스턴스화 방지
" `컴파일러가 기본 생성자를 만든다.` " == " `명시된 생성자가 없다.` "<br/>
이에 따라 `private 생성자`를 선언하면 막을 수 있다. 

> _적절한 **주석**을 달아두는 것이 바람직하다._<br/>
> ( 존재하지만 아예 호출이 안되는 생성자이기 때문에 필요 )
 
```java
public class UtilityClass{
    // 기본 생성자 생성 방지 (인스턴스화 방지)
    private UtilityClass(){
        throw new AssertionError();
    }
}
```
- 명시적 생성자 & `private` → **클래스 외부 접근 불가**
- **예외 처리** → 혹시 모르는 상황 대비