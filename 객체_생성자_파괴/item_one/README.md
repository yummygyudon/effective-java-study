# [Item1] 생성자 대신 "정적 팩토리 메서드"를 고려하라. 
<details open>
    <summary><b>Index</b></summary>
    <div markdown="1">

- [정적 팩토리 메서드](#정적-팩터리-메서드-static-factory-method)
  - [장점](#장점)
  - [서비스 제공자 프레임워크](#-서비스-제공자-프레임-워크)
  - [단점](#단점)
    
    </div>
</details>

<br/>

---
## 정적 팩터리 메서드 `static factory method`
> **⁜ 핵심 ⁜**<br/>
> 
> : **정적 팩토리 메서드**와 **`public` 생성자**간의 장단점을 계산하여 상황에 맞게 사용하기<br/>
> _( 보통 정적 팩토리 메서드가 유리한 경우가 많으므로 무작정 public 생성자를 쓰는 것 멈추기 )_


- 해당 클래스의 인스턴스를 반환하는 단순 정적 메서드
  - `팩토리 메서드` 디자인 패턴과는 다른 개념

<br/>

`public` 생성자를 사용하여 인스턴스를 얻는 방식은<br/>
<u>생성자로 인스턴스를 **직접 생성**</u>하는 방식이다.

이와 별도의 클래스로의 인스턴스를 얻는 수단 중 하나로<br/>
"**정적 팩토리 메서드**"를 활용하는 방법이 있다.

단순히 클래스의 정적 메서드를 통해 그 클래스의 인스턴스를 반환받는 방법이다.

이에 따라 클래스는
클라이언트에 인스턴스를 제공할 때,
`public` 생성자 대신 정적 팩토리 메서드를 사용할 수 있다.<br/>
(_물론 생성자와 함께 사용할 수도 있다._)

> ⁜ **정적 메서드** 
> 
> : **클래스와 연결**되어 있지만, <br/>
> 해당 클래스의 <u>특정 인스턴스와는 연결되어 있지 않은 메서드</u><br/>
> 
> 이러한 메서드에는 <u>클래스의 객체가 입력 인수로 필요하지 않기 때문에</u> <br/>
> 클래스의 **객체를 생성하지 않고** 호출할 수 있습니다.

```java
/**
 * 정적 메서드 valueOf는 기본 타입인 boolean 값을 입력 받고 
 * Boolean 객체에 대한 참조로 변환해준다.
 * 
 * Boolean 클래스의 생성자가 필요 없다.
 */
public static Boolean valueOf(boolean b){
    return b ? Boolean.TRUE : Boolean.False ;
}
```
<br/>

### 장점
> 생성자 방식보다 좋은 장점
#### 1. 이름을 가질 수 있다.
- **생성자** : <u>매개변수와 반환될 객체의 특성</u>을 **제대로 설명하지 못함**.
  - 클래스 설명 문서를 찾아보지 않고는 의미를 파악하기 어려움. 


- **정적 팩토리 메서드** : **이름**을 통해 반환 <u>객체의 특성을 쉽게 묘사</u>할 수 있음.
  - **이름**에 **차별성**을 두어 각각의 차이를 드러낼 수 있음.

_* ex. "값이 소수인 BigInteger 인스턴스 반환" <br/>
`BigInteger(int, int, Random)` vs `BigInteger.probablePrime`_

<br/>
<br/>

#### 2. 호출할 때마다 새로운 인스턴스를 생성하지 않아도 된다.
- 불필요한 객체 생성을 피할 수 있음.
  - 인스턴스를 **미리 만들어 놓는 방식**
  - 새로 생성한 인스턴스를 **캐싱하여 재활용**하는 방식

앞서 알아봤던 `Boolean.valueOf(boolean)`의 경우도 객체를 아예 생성하지 않고 사용하는 것을 알 수 있다.

" <u>생성 비용이 큰 객체가 자주 요청되는 상황</u> "에서 효율성이 극대화된다.<br/>
(`플라이웨이트 : Flyweight`패터과 유사한 기법)

<u>반복되는 요청</u>에 **같은 객체를 반환**하는 식으로<br/>
정적 팩토리 방식의 클래스는 <u>**인스턴스 생명 주기**를 철저히 통제</u>할 수 있다.<br/>
( : 인스턴스 통제`Instance-Controlled`)

> **⁜ 인스턴스 통제의 이유**
> >Flyweight 패턴의 근간
> - **싱글톤**(Singleton) 
> - **인스턴스화 불가**(non-instantiable) 
> - **불변 값 클래스**에서 <u>동치 인스턴스의 **단일성**</u>을 보장

<br/>
<br/>

#### 3. 반환 타입의 "하위 타입 객체"를 반환할 수 있는 능력
> 인터페이스 기반 프레임워크(Interface Ori Framework)
<u>반환 객체의 클래스</u>를 **자유롭게 선택**할 수 있는 유연성이 있기 때문에<br/>
<u>**구현 클래스**를 공개하지 않고도</u>그 객체를 반환할 수 있어서 <br/>
API를 작게 유지할 수 있다.

(`인터페이스 기반 프레임워크`의 핵심 기술<br/> : **정적 팩토리 메서드 반환 타입**으로 <u>인터페이스</u> 사용 _ [장점 4](#4--입력-매개변수--에-따라-u-매번-다른-클래스의-객체-반환-u-가능) 참고)

- _Java 8_ 이전 : **인터페이스**에 <u>**정적 메서드** 선언</u>이 **불가능**
  - <u>**인터페이스**를 반환하는 **정적 메서드**</u>가 필요하면 <br/>" <u>인스턴스화 불가</u> **동반 클래스**(**Companion Class**)"를 만들어 <br/>
  그 안에 정의했었음.

<br/>

_⟪ **자바 컬렉션 프레임워크** ⟫ <br/>
핵심 인터페이스들에 유틸리티 구현체(unmodified~, synchronize,..)를 제공 <br/>
→ 구현체 대부분을 " 단 하나의 **인스턴스화 불가 클래스** (`java.util.Collections`) "에 정적 메서드를 정의하여<br/>
정적 팩토리 메서드를 통해 얻도록 함_

위 자바 컬렉션 프레임워크는 <u>구현체 클래스를 공개하지 않았고</u><br/>
해당 API를 사용하기 위해 **익혀야 하는 개념의 수**와 **난이도**가 낮아진다.

나아가 정적 팩토리 메서드를 사용하는 클라이언트는<br/>
**얻은 객체**를 구현 클래스가 아닌 <u>인터페이스만으로 다룰 수 있게</u> 된다.<br/>
( _ex. `Collections.emptyList()` 반환값 → `List<T>` 인터페이스만으로 다룰 수 있음_ )

> Java 8 이후부터는 인터페이스의 정적 메서드 제한이 사라졌기 때문에 <br/>
> 현재는 <u>인스턴스화 불가 동반 클래스를 둘 필요 없이</u><br/>
> 동반 클래스에 있던 public 정적 메서드들 상당수를 **그냥 인터페이스 자체에** 두면 됨.<br/>
> _But,_ 정적 메서드 구현을 위한 코드 중 많은 부분은 여전히 별도의 `package-private`클래스에 두어야 함.
> 
> Java 9 부터는 <u>private 정적 메서드까지 허용</u>되지만<br/>
> **정적 필드** & **정적 멤버 클래스**는 반드시 `public` 이어야 함.

<br/>
<br/>

#### 4. "입력 매개변수"에 따라 <u>매번 다른 클래스의 객체 반환</u> 가능
<u>반환 타입의 **하위 타입**</u>이기만 하면 _어떤 클래스의 객체를 반환하든 상관없다_.

클라이언트는 **하위 타입 클래스들의 존재**를 모르고<br/>
더 나아가<br/>
팩토리가 <u>반환하는 객체가 **어느 클래스의 인스턴스**인지</u>도 알 수 없으며 알 필요도 없다.<br/>
( " **반환 타입의 하위 타입이기만 하면 OK!** " )

<br/>
<br/>

#### 5. ⌜ 정적 팩토리 메서드를 작성하는 시점 ⌟ 에는 <u>반환 객체의 클래스가 존재하지 않아도 됨</u>.
> 서비스 제공자 프레임워크(Service Provider Framework)의 근간

- 서비스 제공자(provider)는 서비스의 구현체
  - 클라이언트가 필요한 서비스의 구현체를 클라이언트에게 제공하는 역할에 대해 <br/>
    프레임워크가 통제하게끔 하여 클라이언트를 **구현체로부터 분리**
  - 대표적인 예시 : **JDBC**

<br/>
<br/>

---
<br/>

### ⁜ 서비스 제공자 프레임 워크
> `서비스 제공자 프레임 워크` : 서비스 제공자 패턴으로 구현한 프레임워크 <br/>
> `서비스 제공자 인터페이스` : 서비스 제공자 프레임워크에서 제공하는 API

_* Java SE 6 부터 제공 _ `Service Provider Interface` API - `java.util.ServiceLoader`<br/>( JDBC는 자바 6 전에 등장했기 때문에 `ServiceLoader`를 사용하지 않음. )_


<br/>

#### ⟦ 핵심 컴포넌트 인터페이스 ⟧
- **서비스 인터페이스** : 구현체의 <u>동작 정의</u>
  - _JDBC_ - `Connection`


- **제공자 등록 API** : 구현체 <u>등록</u>
  - _JDBC_ - `DriverManger.registerDriver`


- **서비스 접근 API** : 클라이언트의 요청에 대한 <u>서비스의 인스턴스 반환</u>
  - _JDBC_ - `DriverManger.getConnection`
  - 원하는 구현체의 조건 명시 가능
    - 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가면서 반환
  - 서비스 제공자 프레임워크의 근간 (**유연한 정적 팩토리**)


- **서비스 제공자 인터페이스** : 서비스 인터페이스의 인스턴스를 생성하는 팩토리 객체 설명
  - _JDBC_ - `Driver`


<br/>

---
### 단점
#### 1. 하위 클래스 생성 불가
> 상속을 하려면 `public`/`protected` 생성자가 필요하기 때문에<br/>
> <u>정적 팩토리 메서드만 제공</u>하면 **하위 클래스를 만들 수 없다.**

어찌보면 <u>상속보다 **컴포지션 사용**</u>을 **권장**하고<br/>
<u>**불변 타입**으로 만들려면</u> 해당 제약을 지켜야한다는 점에서 장점으로 볼 수도 있음

<br/>

#### 2. 프로그래머가 찾기 어려움

생성자와 같이 API 설명에 명확히 드러나지 않기 때문에<br/>
사용자가 <u>직접</u> 정적 팩토리 메서드 방식 클래스의 **인스턴스화 방식**을 파악해야한다.<br/>
( _API 문서 작성 및 보편적인 규약을 따르는 방식으로 개선_ )

> ⁜ 보편적인 **명명 방식**
> 
> - `from` : <u>매개변수를 하나 받아</u> **해당 타입의 인스턴스를 반환**하는 " **형 변환** 메서드 "
>   - _ex. `Date.from(instant)`_
> 
> 
> - `of` : 여러 매개변수를 받아 **적합한 타입의 인스턴스를 반환**하는 " **집계** 메서드 "
>   - _ex. `EnumSet.of(value1, value2, value3)`_
> 
> 
> - `valueOf` : _from, of_ 의 더 자세한 버전
>   - _ex. `BigInteger.valueOf(Integer.MAX_VALUE)`_
> 
> 
> - `instance` / `getInstance`
>   - (기본) = 해당 클래스 인스턴스 반환
>   - (매개변수) = 매개변수로 명시한 인스턴스 반환
>   - _ex. `StackWalker.getInstance(option)`_
> 
> 
> - `create` / `newInstance` : _instance, getInstance_ 와 같지만, 매번 새로운 인스턴스를 생성한다는 특징
>   - _ex. `Array.newInstance(classObject, arrayLength)`_
> 
> 
> - `get([Type])` : _getInstance_ 와 같으나, <br/>
> 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 사용한다.
>   - _ex. `FileStore fs = Files.getFileStore(path)`_
> 
> 
> - `new([Type])` : _newInstance_ 와 같으나, <br/>
    > 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 사용한다.
>   - _ex. `BufferedReader br = Files.newBufferedReader(path)`_
> 
> 
> - `([Type])` : _get, new_ 간략한 버전
>   - _ex. `Collections.list()`_